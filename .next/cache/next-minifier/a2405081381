{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{hg6j:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"default\",(function(){return r}));var a=n(\"wx14\"),o=n(\"Ff2n\"),i=n(\"q1tI\"),s=n.n(i),c=n(\"7ljp\"),l=n(\"O5+3\"),u=(s.a.createElement,{}),p=\"wrapper\";function r(e){var t=e.components,n=Object(o.a)(e,[\"components\"]);return Object(c.b)(p,Object(a.a)({},u,n,{components:t,mdxType:\"MDXLayout\"}),Object(c.b)(\"h1\",null,\"Validating Inputs\"),Object(c.b)(\"hr\",null),Object(c.b)(\"p\",null,\"   All kinds of input form can be validated, this example can be applied in every kind.\\nBy default, useForm work with yup validation schema, and you can pass a\\nvalidation schema as a parameter in \",Object(c.b)(l.a,{mdxType:\"Code\"},\"useForm\"),\" hook.\"),Object(c.b)(l.a,{mdxType:\"Code\"},\"const [] = useForm(\",\"validation\",\")\"),Object(c.b)(\"p\",null,\"   The validation is run every time the state is changed. By default the \",Object(c.b)(l.a,{mdxType:\"Code\"},\"useForm\"),\" uses the option uncontrolled inputs, it means that values are accessible when onSubmit event is dispatched.\"),Object(c.b)(\"p\",null,\"   If you want to custom the validation it is possible to import useValidation hook.\"),Object(c.b)(\"p\",null,\"   This hook receives the values and a yup validation schema, and return the object errors in every chenge.\"),Object(c.b)(\"p\",null,\"   \",Object(c.b)(\"inlineCode\",{parentName:\"p\"},\"import {useValidation} from 'useforms\")))}r.isMDXComponent=!0}}]);"}